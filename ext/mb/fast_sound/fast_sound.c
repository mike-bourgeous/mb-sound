/*
 * Faster sound routines for internal use by mb-sound, typically fairly
 * straightforward ports from existing Ruby code.
 * (C)2021 Mike Bourgeous
 */
#include <stdlib.h>
#include <math.h>
#include <complex.h>

#include <ruby.h>

#include "numo/narray.h"

enum wave_types {
	OSC_SINE,
	OSC_COMPLEX_SINE,
	OSC_TRIANGLE,
	OSC_COMPLEX_TRIANGLE,
	OSC_SQUARE,
	OSC_COMPLEX_SQUARE,
	OSC_RAMP,
	OSC_COMPLEX_RAMP,
	OSC_GAUSS,
	OSC_PARABOLA,
};

enum filter_types {
	FILT_LOWPASS,
	FILT_HIGHPASS,
	FILT_BANDPASS,
	FILT_NOTCH,
	FILT_ALLPASS,
	FILT_PEAK,
	FILT_LOWSHELF,
	FILT_HIGHSHELF,
};

// Used by cookbook()
struct biquad_coeffs {
	double b0, b1, b2;
	double a1, a2;
	double omega; // angular frequency
};

static ID sym_osc_sine;
static ID sym_osc_complex_sine;
static ID sym_osc_triangle;
static ID sym_osc_complex_triangle;
static ID sym_osc_square;
static ID sym_osc_complex_square;
static ID sym_osc_ramp;
static ID sym_osc_complex_ramp;
static ID sym_osc_gauss;
static ID sym_osc_parabola;

// Automatically generated lookup table of integrate(-2 * arctanh(e ^ (i * x)), x) from -1.5707963267948966 to 0.0
// Generated by experiments/lookup_table.rb from mb-math, then copied and modified from m
// experiments/lookup_table.rb "integrate(-2 * arctanh(e ^ (i * x)), x)" -1.5707963267948966 0.0 101
static double LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[] = {
	1.83193118835444,
	1.83180781576262,
	1.83143766754058,
	1.83082065231093,
	1.82995661765263,
	1.82884534991252,
	1.82748657394065,
	1.82587995274862,
	1.82402508708989,
	1.82192151496077,
	1.81956871102062,
	1.81696608592935,
	1.81411298560028,
	1.81100869036592,
	1.80765241405416,
	1.80404330297178,
	1.80018043479205,
	1.79606281734296,
	1.79168938729175,
	1.78705900872171,
	1.78217047159617,
	1.77702249010453,
	1.77161370088461,
	1.76594266111487,
	1.76000784646978,
	1.75380764893088,
	1.74734037444516,
	1.74060424042216,
	1.73359737305989,
	1.72631780448907,
	1.71876346972417,
	1.71093220340876,
	1.70282173634125,
	1.69442969176628,
	1.6857535814152,
	1.67679080127773,
	1.66753862708531,
	1.65799420948445,
	1.64815456887655,
	1.63801658989825,
	1.6275770155137,
	1.61683244068744,
	1.60577930560301,
	1.59441388838922,
	1.58273229731148,
	1.57073046238141,
	1.55840412633249,
	1.54574883490386,
	1.53275992636771,
	1.51943252022827,
	1.5057615050118,
	1.49174152505741,
	1.47736696620736,
	1.46263194028281,
	1.44753026821644,
	1.43205546169654,
	1.41620070315761,
	1.39995882393024,
	1.38332228033666,
	1.36628312748775,
	1.34883299050186,
	1.33096303282328,
	1.31266392126902,
	1.2939257873736,
	1.27473818453185,
	1.25509004035606,
	1.23496960356404,
	1.21436438459343,
	1.19326108899162,
	1.17164554245173,
	1.14950260614655,
	1.12681608074222,
	1.10356859713828,
	1.07974149156128,
	1.05531466211154,
	1.03026640319184,
	1.0045732133883,
	0.978209571264714,
	0.951147672083024,
	0.923357116553767,
	0.894804540171926,
	0.865453168251795,
	0.835262277060074,
	0.804186534892375,
	0.772175187675088,
	0.739171040340956,
	0.705109165640325,
	0.669915242615786,
	0.633503381583527,
	0.595773220410311,
	0.55660595857116,
	0.515858793504701,
	0.473356862775726,
	0.42888111381683,
	0.382149146272707,
	0.332783047937946,
	0.280250838337874,
	0.223747088396741,
	0.161903864374734,
	0.0918401856348807,
	-8.50583000021389e-15
};

// Automatically generated lookup table of integrate(-2 * arctanh(e ^ (i * x)), x) from -0.1 to 0.0
// Generated by experiments/lookup_table.rb from mb-math, then copied and modified from mb-math to mb-sound
// experiments/lookup_table.rb "integrate(-2 * arctanh(e ^ (i * x)), x)" -0.1 0.0 21
static double SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[] = {
	0.399545439850515,
	0.384443605455943,
	0.369078095285853,
	0.353434288916255,
	0.337495840580432,
	0.321244354892652,
	0.304658975812297,
	0.287715857726498,
	0.270387473083062,
	0.252641688069872,
	0.234440500179617,
	0.215738267210309,
	0.196479142339785,
	0.176593212908555,
	0.155990402312772,
	0.134550231829575,
	0.112103181494428,
	0.0883926901258597,
	0.0629831458876054,
	0.0349573192633147,
	0
};

// Behaves like Ruby's % operator instead of fmod
// Wraps X to be between 0 and Y
static double wrap(double x, double y)
{
	// this could instead be fmod(x, y) + y if x is negative
	return x - y * floor(x / y);
}

// Wraps X to be between 0 and Y
static ssize_t wrapsize(ssize_t x, ssize_t y)
{
	if (x >= 0 && x < y) {
		return x;
	}

	if (x < 0) {
		return x % y + y;
	}

	return x % y;
}

// Direct port from #fetch_bounce in mb-math, used for trig lookup tables.
static double fetch_bounce(double table[], ssize_t len, ssize_t idx)
{
	if (idx >= 0 && idx < len) {
		return table[idx];
	}

	idx = wrapsize(idx, len * 2 - 2);

	if (idx >= len - 1) {
		idx = (2 * len - 2) - idx;
	}

	if (idx < 0 || idx >= len) {
		rb_raise(rb_eRuntimeError, "Bad index %zd", idx);
	}

	return table[idx];
}

// Handles expansion of quarter-wave lookup table (copied/modified from mb-math)
// Also see fetch_bounce from mb-math
static double get_lookup_i2aeixx(double table[], ssize_t len, ssize_t idx)
{
	double v = fetch_bounce(table, len, idx);

	if (idx >= len || idx <= -len) {
		v *= -1;
	}

	return v;
}

// Used for trig table interpolation
static double simple_catmull_rom(double p0, double p1, double p2, double p3, double blend)
{
	double t0 = 0.0;
	double t1 = 1.0;
	double t2 = 2.0;
	double t3 = 3.0;

	double d10 = t1 - t0;
	double d20 = t2 - t0;
	double d21 = t2 - t1;
	double d31 = t3 - t1;
	double d32 = t3 - t2;
	double t = blend * d21 + t1;
	double d0t = t0 - t;
	double d1t = t1 - t;
	double d2t = t2 - t;
	double d3t = t3 - t;

	double a1 = p0 * (d1t / d10) - p1 * (d0t / d10);
	double a2 = p1 * (d2t / d21) - p2 * (d1t / d21);
	double a3 = p2 * (d3t / d32) - p3 * (d2t / d32);
	double b1 = a1 * (d2t / d20) - a2 * (d0t / d20);
	double b2 = a2 * (d3t / d31) - a3 * (d1t / d31);

	return b1 * (d2t / d21) - b2 * (d1t / d21);
}

// Automatically generated (then manually modified) lookup-table-based
// approximation of integrate(-2 * arctanh(e ^ (i * x)), x)
// Uses 101 steps between -1.5707963267948966 and 0.0
// Generated by experiments/lookup_table.rb from mb-math with the help of Sage
static double complex lookup_integrate_2_arctanh_e_i_x_x(double x)
{
	double offset;
	double *table;
	size_t len;

	x = wrap(x + M_PI, 2.0 * M_PI) - M_PI;

	if (x > -0.09 && x < 0.09) {
		offset = (x + 0.1) * 20 / 0.1;
		table = SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	} else if (x > M_PI - 0.098) {
		offset = (x - M_PI + 0.1) * -20 / 0.1 + 40;
		table = SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	} else if (x < -M_PI + 0.098) {
		offset = (x + M_PI - 0.1) * -20 / 0.1;
		table = SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(SMALL_LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	} else {
		offset = (x + 1.5707963267948966) * 100 / 1.5707963267948966;
		table = LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X;
		len = sizeof(LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X) / sizeof(LOOKUP_INTEGRATE_2_ARCTANH_E_I_X_X[0]);
	}

	ssize_t idx = floor(offset);
	double frac = offset - idx;
	double real = simple_catmull_rom(
			get_lookup_i2aeixx(table, len, idx - 1),
			get_lookup_i2aeixx(table, len, idx),
			get_lookup_i2aeixx(table, len, idx + 1),
			get_lookup_i2aeixx(table, len, idx + 2),
			frac
			);

	// Triangle wave borrowed from mb-sound, back from mb-math
	double phi = wrap(x - M_PI_2, 2.0 * M_PI);
	double imag;
	if (phi < M_PI_2) {
		// Initial rise from 0..1 in 0..pi/2
		imag = phi * M_2_PI;
	} else if (phi < (1.5 * M_PI)) {
		// Fall from 1..-1 in pi/2..3pi/2
		imag = 2.0 - phi * M_2_PI;
	} else {
		// Final rise from -1..0 in 3pi/2..2pi
		imag = phi * M_2_PI - 4.0;
	}

	// 2.4674...*i == -pi*log(2) + I*dilog(2)
	return real - I * 2.46740110027234 * imag;
}

static double complex csc_int(double complex z)
{
	return -2.0 * conj(catanh(cexp(I * z))) + M_PI / (2.0 * I);
}

static double complex csc_int_int(double x)
{
	return lookup_integrate_2_arctanh_e_i_x_x(x);
}

static double complex cot_int(double complex z)
{
	return -M_2_PI * clog(cexp(I * z) + I) + I;
}

static double complex osc_sample(enum wave_types wave_type, complex double phi)
{
	double x;
	double complex z;
	double im;

	switch(wave_type) {
		case OSC_SINE:
			return sin(creal(phi));

		case OSC_COMPLEX_SINE:
			return cexp(I * (phi - M_PI / 2));

		case OSC_TRIANGLE:
			if (creal(phi) < M_PI_2) {
				// Rise from 0..1 in 0..pi/2
				return phi * M_2_PI;
			} else if (creal(phi) < (M_PI + M_PI_2)) {
				// Fall from 1..-1 in pi/2..3pi/2
				return 2.0 - phi * M_2_PI;
			} else {
				// Rise from -1.0 in 3pi/2..2pi
				return phi * M_2_PI - 4.0;
			}

		case OSC_COMPLEX_TRIANGLE:
			// see lib/mb/sound/oscillator.rb
			// 2.4674...*i == -pi*log(2) + I*dilog(2)
			return csc_int_int(creal(phi) + M_PI_2) * I / 2.46740110027234;

		case OSC_SQUARE:
			// TODO: Normalize for RMS instead of peak?
			if (creal(phi) < M_PI) {
				return 1.0;
			} else {
				return -1.0;
			}

		case OSC_COMPLEX_SQUARE:
			z = 2.0 * conj(csc_int(phi)) * I / M_PI + 1.0;
			if (isinf(creal(z)) || isinf(cimag(z))) {
				z = 2.0 * conj(csc_int(phi + 0.0000001)) * I / M_PI + 1.0;
			}

			im = cimag(z);
			if (im > 3.8) {
				z = creal(z) + I * 3.8;
			} else if (im < -3.8) {
				z = creal(z) - I * 3.8;
			}

			return z;

		case OSC_RAMP:
			if (creal(phi) < M_PI) {
				// Initial rise from 0..1 in 0..pi
				return phi / M_PI;
			} else {
				// Final rise from -1..0 in pi..2pi
				return phi / M_PI - 2.0;
			}

		case OSC_COMPLEX_RAMP:
			z = cot_int(phi + M_PI_2) * I;

			im = cimag(z);
			if (im > 3.5) {
				z = creal(z) + I * 3.5;
			} else if (im < -3.5) {
				z = creal(z) - I * 3.5;
			}

			return z;

		case OSC_GAUSS:
			x = creal(phi) / M_PI;
			if (x < 1.0) {
				x = (sqrt(2.0 * log(1.6487212707 / (1.0 - x))) - 1) * 0.7071067811865476;
			} else {
				x = (1 - sqrt(2.0 * log(1.6487212707 / (x - 1.0)))) * 0.7071067811865476;
			}

			if (x < -3) {
				x = -3;
			} else if (x > 3) {
				x = 3;
			}

			return x;

		case OSC_PARABOLA:
			if (creal(phi) < M_PI) {
				x = 1.0 - phi * M_2_PI;
				return 1.0 - x * x;
			} else {
				x = phi * M_2_PI - 3.0;
				return x * x - 1.0;
			}

		default:
			return 0;
	}
}

static inline _Bool double_is_tiny(double v)
{
	return v < 1e-18 && v > -1e-18;
}

// Converted from lib/mb/sound/filter/biquad.rb
static double biquad_filter(
		double b0, double b1, double b2,
		double a1, double a2,
		double x0, double x1, double x2,
		double y1, double y2
		)
{
	double out = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;

	// Prevent denormals
	if (double_is_tiny(out) && double_is_tiny(y1) && double_is_tiny(y2)) {
		out = 0;
	}

	return out;
}

static double complex biquad_complex(
		double complex b0, double complex b1, double complex b2,
		double complex a1, double complex a2,
		double complex x0, double complex x1, double complex x2,
		double complex y1, double complex y2
		)
{
	double complex out = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;

	// Prevent denormals
	double real = creal(out);
	double imag = cimag(out);
	if (double_is_tiny(real) && double_is_tiny(creal(y1)) && double_is_tiny(creal(y2))) {
		real = 0;
	}
	if (double_is_tiny(imag) && double_is_tiny(cimag(y1)) && double_is_tiny(cimag(y2))) {
		imag = 0;
	}

	return real + I * imag;
}

// Pass NaN for quality/bandwidth/slope to indicate "not set".
static struct biquad_coeffs cookbook(enum filter_types ftype, double rate, double center, double db_gain, double quality, double bandwidth_oct, double shelf_slope)
{
	struct biquad_coeffs coeffs = {};

	double amp = 0;
	if (!isnan(db_gain)) {
		amp = pow(10.0, db_gain / 40.0);
	}

	coeffs.omega = 2.0 * M_PI * center / rate;
	double cosine = cos(coeffs.omega);
	double sine = sin(coeffs.omega);

	double alpha;
	if (!isnan(quality)) {
		alpha = sine / (2.0 * quality);
	} else if (!isnan(bandwidth_oct)) {
		alpha = sine * sinh(M_LN2 / 2.0 * bandwidth_oct * coeffs.omega / sine);
	} else if (!isnan(shelf_slope)) {
		alpha = sine * 0.5 * sqrt((amp + 1.0 / amp) * (1.0 / shelf_slope - 1) + 2);
	} else {
		alpha = sine / 2.0; // assume quality of 1.0 if nothing was given
	}

	double a0_inv, am1, ap1, asq2al;
	switch(ftype) {
		case FILT_LOWPASS:
			a0_inv = 1.0 / (1.0 + alpha);
			coeffs.a1 = -2.0 * cosine * a0_inv;
			coeffs.a2 = (1.0 - alpha) * a0_inv;
			coeffs.b0 = 0.5 * (1.0 - cosine) * a0_inv;
			coeffs.b1 = (1.0 - cosine) * a0_inv;
			coeffs.b2 = 0.5 * (1.0 - cosine) * a0_inv;
			break;

		case FILT_HIGHPASS:
			a0_inv = 1.0 / (1.0 + alpha);
			coeffs.a1 = -2.0 * cosine * a0_inv;
			coeffs.a2 = (1.0 - alpha) * a0_inv;
			coeffs.b0 = 0.5 * (1.0 + cosine) * a0_inv;
			coeffs.b1 = -(1.0 + cosine) * a0_inv;
			coeffs.b2 = 0.5 * (1.0 + cosine) * a0_inv;
			break;

		case FILT_BANDPASS:
			a0_inv = 1.0 / (1.0 + alpha);
			coeffs.a1 = -2.0 * cosine * a0_inv;
			coeffs.a2 = (1.0 - alpha) * a0_inv;
			coeffs.b0 = alpha * a0_inv;
			coeffs.b1 = 0;
			coeffs.b2 = -alpha * a0_inv;
			break;

		case FILT_NOTCH:
			a0_inv = 1.0 / (1.0 + alpha);
			coeffs.a1 = -2.0 * cosine * a0_inv;
			coeffs.a2 = (1.0 - alpha) * a0_inv;
			coeffs.b0 = a0_inv;
			coeffs.b1 = -2.0 * cosine * a0_inv;
			coeffs.b2 = a0_inv;
			break;

		case FILT_ALLPASS:
			a0_inv = 1.0 / (1.0 + alpha);
			coeffs.a1 = -2.0 * cosine * a0_inv;
			coeffs.a2 = (1.0 - alpha) * a0_inv;
			coeffs.b0 = (1.0 - alpha) * a0_inv;
			coeffs.b1 = -2.0 * cosine * a0_inv;
			coeffs.b2 = (1.0 + alpha) * a0_inv;
			break;

		case FILT_PEAK:
			a0_inv = 1.0 / (1.0 + alpha / amp);
			coeffs.a1 = -2.0 * cosine * a0_inv;
			coeffs.a2 = (1.0 - alpha / amp) * a0_inv;
			coeffs.b0 = (1.0 + alpha * amp) * a0_inv;
			coeffs.b1 = -2.0 * cosine * a0_inv;
			coeffs.b2 = (1.0 - alpha * amp) * a0_inv;
			break;

		case FILT_LOWSHELF:
			ap1 = amp + 1;
			am1 = amp - 1;
			asq2al = 2.0 * sqrt(amp) * alpha;

			a0_inv = 1.0 / (ap1 + am1 * cosine + asq2al);
			coeffs.a1 = -2.0 * (am1 + ap1 * cosine) * a0_inv;
			coeffs.a2 = (ap1 + am1 * cosine - asq2al) * a0_inv;
			coeffs.b0 = amp * (ap1 - am1 * cosine + asq2al) * a0_inv;
			coeffs.b1 = 2.0 * amp * (am1 - ap1 * cosine) * a0_inv;
			coeffs.b2 = amp * (ap1 - am1 * cosine - asq2al) * a0_inv;

			break;

		case FILT_HIGHSHELF:
			ap1 = amp + 1;
			am1 = amp - 1;
			asq2al = 2.0 * sqrt(amp) * alpha;

			a0_inv = 1.0 / (ap1 - am1 * cosine + asq2al);
			coeffs.a1 = 2.0 * (am1 - ap1 * cosine) * a0_inv;
			coeffs.a2 = (ap1 - am1 * cosine - asq2al) * a0_inv;
			coeffs.b0 = amp * (ap1 + am1 * cosine + asq2al) * a0_inv;
			coeffs.b1 = -2.0 * amp * (am1 + ap1 * cosine) * a0_inv;
			coeffs.b2 = amp * (ap1 + am1 * cosine - asq2al) * a0_inv;

			break;

		default:
			// Pass-through unity gain filter if filter type was invalid
			coeffs.b0 = 1;
			coeffs.b1 = 0;
			coeffs.b2 = 0;
			coeffs.a1 = 0;
			coeffs.a2 = 0;
	}

	return coeffs;
}

static double smoothstep(double x)
{
	return 3*x*x - 2*x*x*x;
}

static double smootherstep(double x)
{
	return 6*x*x*x*x*x - 15*x*x*x*x + 10*x*x*x;
}

static double adsr(
		double time,
		double attack,
		double decay,
		double sustain,
		double release,
		double peak,
		_Bool on
		)
{
	double release_start = attack + decay;
	double total = attack + decay + release;

	double value;

	if (on) {
		if (time < 0) {
			value = 0.0;
		} else if (time < attack) {
			value = smoothstep(time / attack);
		} else if (time < release_start) {
			value = 1.0 - smoothstep((time - attack) / decay) * (1.0 - sustain);
		} else {
			value = sustain;
		}
	} else {
		if (time < release_start) {
			value = sustain;
		} else if (time < total) {
			value = (1.0 - smoothstep((time - release_start) / release)) * sustain;
		} else {
			value = 0.0;
		}
	}

	return value * peak;
}

static void ensure_inplace_sfloat(VALUE *narray, _Bool *was_inplace)
{
	int dim = RNARRAY_NDIM(*narray);
	if (dim != 1) {
		rb_raise(rb_eArgError, "Only 1D NArrays may be processed (got %d dimensions)", dim);
	}

	_Bool prior_inplace = !!TEST_INPLACE(*narray);

	*narray = rb_funcall(numo_cSFloat, rb_intern("cast"), 1, *narray);

	if (!RTEST(nary_check_contiguous(*narray)) || !prior_inplace) {
		*narray = nary_dup(*narray);
		SET_INPLACE(*narray);
		prior_inplace = 0;
	}

	if (was_inplace != NULL) {
		*was_inplace = prior_inplace;
	}
}

static void ensure_inplace_sfloat_or_scomplex(VALUE *narray, _Bool *was_inplace)
{
	int dim = RNARRAY_NDIM(*narray);
	if (dim != 1) {
		rb_raise(rb_eArgError, "Only 1D NArrays may be processed (got %d dimensions)", dim);
	}

	_Bool prior_inplace = !!TEST_INPLACE(*narray);

	if (CLASS_OF(*narray) == numo_cDComplex || CLASS_OF(*narray) == numo_cSComplex) {
		*narray = rb_funcall(numo_cSComplex, rb_intern("cast"), 1, *narray);
	} else {
		*narray = rb_funcall(numo_cSFloat, rb_intern("cast"), 1, *narray);
	}

	if (!RTEST(nary_check_contiguous(*narray)) || !prior_inplace) {
		*narray = nary_dup(*narray);
		SET_INPLACE(*narray);
		prior_inplace = 0;
	}

	if (was_inplace != NULL) {
		*was_inplace = prior_inplace;
	}
}

static void ensure_sfloat(VALUE *narray)
{
	int dim = RNARRAY_NDIM(*narray);
	if (dim != 1) {
		rb_raise(rb_eArgError, "Only 1D NArrays may be processed (got %d dimensions)", dim);
	}

	*narray = rb_funcall(numo_cSFloat, rb_intern("cast"), 1, *narray);

	if (!RTEST(nary_check_contiguous(*narray))) {
		*narray = nary_dup(*narray);
	}
}

static void ensure_scomplex(VALUE *narray)
{
	int dim = RNARRAY_NDIM(*narray);
	if (dim != 1) {
		rb_raise(rb_eArgError, "Only 1D NArrays may be processed (got %d dimensions)", dim);
	}

	*narray = rb_funcall(numo_cSComplex, rb_intern("cast"), 1, *narray);

	if (!RTEST(nary_check_contiguous(*narray))) {
		*narray = nary_dup(*narray);
	}
}


static enum wave_types find_wave_type(ID wave_type)
{
	if (wave_type == sym_osc_sine) {
		return OSC_SINE;
	}
	if (wave_type == sym_osc_complex_sine) {
		return OSC_COMPLEX_SINE;
	}
	if (wave_type == sym_osc_triangle) {
		return OSC_TRIANGLE;
	}
	if (wave_type == sym_osc_complex_triangle) {
		return OSC_COMPLEX_TRIANGLE;
	}
	if (wave_type == sym_osc_square) {
		return OSC_SQUARE;
	}
	if (wave_type == sym_osc_complex_square) {
		return OSC_COMPLEX_SQUARE;
	}
	if (wave_type == sym_osc_ramp) {
		return OSC_RAMP;
	}
	if (wave_type == sym_osc_complex_ramp) {
		return OSC_COMPLEX_RAMP;
	}
	if (wave_type == sym_osc_gauss) {
		return OSC_GAUSS;
	}
	if (wave_type == sym_osc_parabola) {
		return OSC_PARABOLA;
	}

	rb_raise(rb_eRuntimeError, "Invalid wave type given: %"PRIsVALUE, wave_type);
}

static complex double num_to_complex(VALUE z)
{
	double real, imag;

	if (!RB_TYPE_P(z, T_COMPLEX)) {
		real = NUM2DBL(z);
		imag = 0;
	} else {
		real = NUM2DBL(rb_complex_real(z));
		imag = NUM2DBL(rb_complex_imag(z));
	}

	return real + I * imag;
}

static VALUE complex_to_num(double complex z)
{
	return rb_dbl_complex_new(creal(z), cimag(z));
}

static VALUE ruby_csc_int(VALUE self, VALUE z)
{
	return complex_to_num(csc_int(num_to_complex(z)));
}

static VALUE ruby_csc_int_int(VALUE self, VALUE z)
{
	return complex_to_num(csc_int_int(num_to_complex(z)));
}

static VALUE ruby_cot_int(VALUE self, VALUE z)
{
	return complex_to_num(cot_int(num_to_complex(z)));
}

static VALUE ruby_smoothstep(VALUE self, VALUE x)
{
	return rb_float_new(smoothstep(NUM2DBL(x)));
}

static VALUE ruby_smootherstep(VALUE self, VALUE x)
{
	return rb_float_new(smootherstep(NUM2DBL(x)));
}

static VALUE ruby_fmod(VALUE self, VALUE x, VALUE y)
{
	return rb_float_new(fmod(NUM2DBL(x), NUM2DBL(y)));
}

static VALUE ruby_remainder(VALUE self, VALUE x, VALUE y)
{
	return rb_float_new(remainder(NUM2DBL(x), NUM2DBL(y)));
}

static VALUE ruby_wrap(VALUE self, VALUE x, VALUE y)
{
	return rb_float_new(wrap(NUM2DBL(x), NUM2DBL(y)));
}

static VALUE ruby_wrapsize(VALUE self, VALUE x, VALUE y)
{
	return SSIZET2NUM(wrapsize(NUM2SSIZET(x), NUM2SSIZET(y)));
}

static VALUE ruby_idiv(VALUE self, VALUE x, VALUE y)
{
	return SSIZET2NUM(NUM2SSIZET(x) / NUM2SSIZET(y));
}

static VALUE ruby_fdiv(VALUE self, VALUE x, VALUE y)
{
	return rb_float_new(NUM2DBL(x) / NUM2DBL(y));
}

static VALUE ruby_imod(VALUE self, VALUE x, VALUE y)
{
	return SSIZET2NUM(NUM2SSIZET(x) % NUM2SSIZET(y));
}

static VALUE ruby_f64to32(VALUE self, VALUE x)
{
	volatile float y = NUM2DBL(x);
	return rb_float_new(y);
}

// Splits complex into real and imaginary
static VALUE ruby_complex(VALUE self, VALUE z)
{
	double complex c = num_to_complex(z);

	return rb_ary_new_from_args(2, rb_float_new(creal(c)), rb_float_new(cimag(c)));
}

static VALUE ruby_narray_to_array(VALUE self, VALUE narray)
{
	narray = rb_funcall(numo_cDComplex, rb_intern("cast"), 1, narray);
	size_t length = RNARRAY_SHAPE(narray)[0];
	VALUE out = rb_ary_new_capa(length);

	rb_funcall(narray, rb_intern("debug_info"), 0);
	rb_warn("Size is %zu, ndim is %d, length is %zu\n", RNARRAY_SIZE(narray), RNARRAY_NDIM(narray), length);

	double complex *ptr = (double complex *)(nary_get_pointer_for_read(narray) + nary_get_offset(narray));
	for(size_t i = 0; i < length; i++) {
		rb_ary_store(out, i, complex_to_num(ptr[i]));
	}

	return out;
}

static VALUE fill_narray_with_function(VALUE narray, double (*func)(double))
{
	_Bool was_inplace;
	ensure_inplace_sfloat_or_scomplex(&narray, &was_inplace);

	_Bool complex_buffer = CLASS_OF(narray) == numo_cSComplex;

	size_t length = RNARRAY_SHAPE(narray)[0];

	float complex *complex_ptr;
	float *float_ptr;
	if (complex_buffer) {
		complex_ptr = (float complex *)(nary_get_pointer_for_write(narray) + nary_get_offset(narray));
	} else {
		float_ptr = (float *)(nary_get_pointer_for_write(narray) + nary_get_offset(narray));
	}

	for (size_t i = 0; i < length; i++) {
		double x = ((double)i + 0.5) / (double)length; // symmetric, exclusive endpoints
		double v = func(x);

		if (complex_buffer) {
			complex_ptr[i] = v;
		} else {
			float_ptr[i] = v;
		}
	}

	if (!was_inplace) {
		UNSET_INPLACE(narray);
	}

	return narray;
}

/*
 * Fills the given narray (or a new narray if the narray is not inplace) with a
 * smoothstep curve from 0 to 1 (exclusive on both ends and symmetric).
 */
static VALUE ruby_smoothstep_buf(VALUE self, VALUE narray)
{
	return fill_narray_with_function(narray, smoothstep);
}

/*
 * Fills the given narray (or a new narray if the narray is not inplace) with a
 * smootherstep curve from 0 to 1 (exclusive on both ends and symmetric).
 */
static VALUE ruby_smootherstep_buf(VALUE self, VALUE narray)
{
	return fill_narray_with_function(narray, smootherstep);
}

/*
 * Calculates the natural logarithm of every element in the NArray.  Leaves
 * SFloat, SComplex, and DComplex as their original type, converts everything
 * else to DFloat.
 */
static VALUE ruby_narray_log(VALUE self, VALUE narray)
{
	VALUE ntype = CLASS_OF(narray);
	if (ntype != numo_cSFloat && ntype != numo_cDFloat && ntype != numo_cSComplex && ntype != numo_cDComplex) {
		narray = rb_funcall(numo_cDFloat, rb_intern("cast"), 1, narray);
		ntype = numo_cDFloat;
	}

	_Bool was_inplace = !!TEST_INPLACE(narray);
	if (!RTEST(nary_check_contiguous(narray)) || !was_inplace) {
		narray = nary_dup(narray);
		SET_INPLACE(narray);
		was_inplace = 0;
	}

	size_t length = RNARRAY_SIZE(narray);

	if (ntype == numo_cSFloat) {
		float *ptr = (float *)(nary_get_pointer_for_read_write(narray) + nary_get_offset(narray));
		for (size_t i = 0; i < length; i++) {
			ptr[i] = logf(ptr[i]);
		}
	} else if (ntype == numo_cDFloat) {
		double *ptr = (double *)(nary_get_pointer_for_read_write(narray) + nary_get_offset(narray));
		for (size_t i = 0; i < length; i++) {
			ptr[i] = log(ptr[i]);
		}
	} else if (ntype == numo_cSComplex) {
		float complex *ptr = (float complex *)(nary_get_pointer_for_read_write(narray) + nary_get_offset(narray));
		for (size_t i = 0; i < length; i++) {
			ptr[i] = clogf(ptr[i]);
		}
	} else if (ntype == numo_cDComplex) {
		double complex *ptr = (double complex *)(nary_get_pointer_for_read_write(narray) + nary_get_offset(narray));
		for (size_t i = 0; i < length; i++) {
			ptr[i] = clog(ptr[i]);
		}
	} else {
		rb_raise(rb_eException, "BUG: Unexpected type %"PRIsVALUE, ntype);
	}

	if (!was_inplace) {
		UNSET_INPLACE(narray);
	}

	return narray;
}

/*
 * Calculates the base two logarithm of every element in the NArray.  Leaves
 * SFloat, SComplex, and DComplex as their original type, converts everything
 * else to DFloat.
 */
static VALUE ruby_narray_log2(VALUE self, VALUE narray)
{
	VALUE ntype = CLASS_OF(narray);
	if (ntype != numo_cSFloat && ntype != numo_cDFloat && ntype != numo_cSComplex && ntype != numo_cDComplex) {
		narray = rb_funcall(numo_cDFloat, rb_intern("cast"), 1, narray);
		ntype = numo_cDFloat;
	}

	_Bool was_inplace = !!TEST_INPLACE(narray);
	if (!RTEST(nary_check_contiguous(narray)) || !was_inplace) {
		narray = nary_dup(narray);
		SET_INPLACE(narray);
		was_inplace = 0;
	}

	size_t length = RNARRAY_SIZE(narray);

	// TODO: Find a way to deduplicate with natural log; C doesn't actually
	// have clog2 or clog10, so they need special handling for complex
	if (ntype == numo_cSFloat) {
		float *ptr = (float *)(nary_get_pointer_for_read_write(narray) + nary_get_offset(narray));
		for (size_t i = 0; i < length; i++) {
			ptr[i] = log2f(ptr[i]);
		}
	} else if (ntype == numo_cDFloat) {
		double *ptr = (double *)(nary_get_pointer_for_read_write(narray) + nary_get_offset(narray));
		for (size_t i = 0; i < length; i++) {
			ptr[i] = log2(ptr[i]);
		}
	} else if (ntype == numo_cSComplex) {
		float complex *ptr = (float complex *)(nary_get_pointer_for_read_write(narray) + nary_get_offset(narray));
		for (size_t i = 0; i < length; i++) {
			ptr[i] = clogf(ptr[i]) / logf(2);
		}
	} else if (ntype == numo_cDComplex) {
		double complex *ptr = (double complex *)(nary_get_pointer_for_read_write(narray) + nary_get_offset(narray));
		for (size_t i = 0; i < length; i++) {
			ptr[i] = clog(ptr[i]) / log(2);
		}
	} else {
		rb_raise(rb_eException, "BUG: Unexpected type %"PRIsVALUE, ntype);
	}

	if (!was_inplace) {
		UNSET_INPLACE(narray);
	}

	return narray;
}

/*
 * Calculates the base ten logarithm of every element in the NArray.  Leaves
 * SFloat, SComplex, and DComplex as their original type, converts everything
 * else to DFloat.
 */
static VALUE ruby_narray_log10(VALUE self, VALUE narray)
{
	VALUE ntype = CLASS_OF(narray);
	if (ntype != numo_cSFloat && ntype != numo_cDFloat && ntype != numo_cSComplex && ntype != numo_cDComplex) {
		narray = rb_funcall(numo_cDFloat, rb_intern("cast"), 1, narray);
		ntype = numo_cDFloat;
	}

	_Bool was_inplace = !!TEST_INPLACE(narray);
	if (!RTEST(nary_check_contiguous(narray)) || !was_inplace) {
		narray = nary_dup(narray);
		SET_INPLACE(narray);
		was_inplace = 0;
	}

	size_t length = RNARRAY_SIZE(narray);

	// TODO: Find a way to deduplicate with natural log; C doesn't actually
	// have clog2 or clog10, so they need special handling for complex
	if (ntype == numo_cSFloat) {
		float *ptr = (float *)(nary_get_pointer_for_read_write(narray) + nary_get_offset(narray));
		for (size_t i = 0; i < length; i++) {
			ptr[i] = log10f(ptr[i]);
		}
	} else if (ntype == numo_cDFloat) {
		double *ptr = (double *)(nary_get_pointer_for_read_write(narray) + nary_get_offset(narray));
		for (size_t i = 0; i < length; i++) {
			ptr[i] = log10(ptr[i]);
		}
	} else if (ntype == numo_cSComplex) {
		float complex *ptr = (float complex *)(nary_get_pointer_for_read_write(narray) + nary_get_offset(narray));
		for (size_t i = 0; i < length; i++) {
			ptr[i] = clogf(ptr[i]) / logf(10);
		}
	} else if (ntype == numo_cDComplex) {
		double complex *ptr = (double complex *)(nary_get_pointer_for_read_write(narray) + nary_get_offset(narray));
		for (size_t i = 0; i < length; i++) {
			ptr[i] = clog(ptr[i]) / log(10);
		}
	} else {
		rb_raise(rb_eException, "BUG: Unexpected type %"PRIsVALUE, ntype);
	}

	if (!was_inplace) {
		UNSET_INPLACE(narray);
	}

	return narray;
}


static VALUE ruby_osc(VALUE self, VALUE wave_type, VALUE phi)
{
	enum wave_types wt = find_wave_type(SYM2ID(wave_type));

	double complex result = osc_sample(wt, num_to_complex(phi));

	if (cimag(result) != 0) {
		return rb_dbl_complex_new(creal(result), cimag(result));
	} else {
		return rb_float_new(creal(result));
	}
}

struct synthesize_params {
	enum wave_types wt;
	double freq;
	double phase;
	double adv;
	double rndadv;
	double g;
	double off;
	double phi;
	complex float *complex_ptr;
	float *float_ptr;
	size_t length;
	complex float *freqptr;
	complex float *phaseptr;
};

// for calling from ruby_synthesize() without the gvl
static void synthesize_loop(void *data)
{
	struct synthesize_params *p = data;

	double complex delta;
	double complex v;
	for (size_t i = 0; i < p->length; i++) {
		if (p->freqptr) {
			p->freq = p->freqptr[i];
		}

		if (p->phaseptr) {
			p->phase = p->phaseptr[i];
		}

		if (p->rndadv != 0) {
			delta = p->freq * (p->adv + drand48() * p->rndadv);
		} else {
			delta = p->freq * p->adv;
		}

		if (p->wt == OSC_COMPLEX_SQUARE || p->wt == OSC_COMPLEX_RAMP) {
			// Ensure symmetric imaginary components when sampled exactly on period
			v = osc_sample(p->wt, p->phi + delta / 2.0 + p->phase);
		} else {
			v = osc_sample(p->wt, p->phi + p->phase);
		}

		v = v * p->g + p->off;

		if (p->complex_ptr) {
			p->complex_ptr[i] = v;
		} else {
			p->float_ptr[i] = creal(v);
		}

		p->phi = wrap(creal(p->phi + delta), M_PI * 2.0) + I * wrap(cimag(p->phi + delta), M_PI * 2.0);
	}


}

// state contains [phi] and will be modified in place
static VALUE ruby_synthesize(VALUE self, VALUE buffer, VALUE wave_type, VALUE frequency, VALUE phase_mod, VALUE advance, VALUE random_advance, VALUE gain, VALUE offset, VALUE state)
{
	Check_Type(state, T_ARRAY);

	if (RARRAY_LEN(state) != 1) {
		rb_raise(rb_eArgError, "State array must have exactly one numeric element");
	}

	enum wave_types wt = find_wave_type(SYM2ID(wave_type));

	double freq;
	double phase;
	double adv = NUM2DBL(advance);
	double rndadv = NUM2DBL(random_advance);
	double g = NUM2DBL(gain);
	double off = NUM2DBL(offset);
	double phi = NUM2DBL(rb_ary_entry(state, 0));

	_Bool was_inplace;
	ensure_inplace_sfloat_or_scomplex(&buffer, &was_inplace);

	_Bool complex_buffer = CLASS_OF(buffer) == numo_cSComplex || CLASS_OF(buffer) == numo_cDComplex;
	complex float *complex_ptr = NULL;
	float *float_ptr = NULL;

	size_t length = RNARRAY_SHAPE(buffer)[0];

	complex float *freqptr = NULL;
	if (CLASS_OF(frequency) == numo_cDFloat || CLASS_OF(frequency) == numo_cSFloat || CLASS_OF(frequency) == numo_cSComplex || CLASS_OF(frequency) == numo_cDComplex) {
		if (RNARRAY_SHAPE(frequency)[0] != length) {
			rb_raise(rb_eArgError, "Frequency array length does not match sample buffer length");
		}

		ensure_scomplex(&frequency);
		freqptr = (float complex *)(nary_get_pointer_for_read(frequency) + nary_get_offset(frequency));
		freq = freqptr[0];
	} else {
		freq = NUM2DBL(frequency);
	}

	complex float *phaseptr = NULL;
	if (CLASS_OF(phase_mod) == numo_cDFloat || CLASS_OF(phase_mod) == numo_cSFloat || CLASS_OF(phase_mod) == numo_cSComplex || CLASS_OF(phase_mod) == numo_cDComplex) {
		if (RNARRAY_SHAPE(phase_mod)[0] != length) {
			rb_raise(rb_eArgError, "Phase modulation array length does not match sample buffer length");
		}

		ensure_scomplex(&phase_mod);
		phaseptr = (float complex *)(nary_get_pointer_for_read(phase_mod) + nary_get_offset(phase_mod));
		phase = phaseptr[0];
	} else if (RTEST(phase_mod)) {
		phase = NUM2DBL(phase_mod);
	} else {
		phase = 0;
	}

	if (complex_buffer) {
		complex_ptr = (float complex *)(nary_get_pointer_for_write(buffer) + nary_get_offset(buffer));
	} else {
		float_ptr = (float *)(nary_get_pointer_for_write(buffer) + nary_get_offset(buffer));
	}

	struct synthesize_params p = {
		.wt = wt,
		.freq = freq,
		.phase = phase,
		.adv = adv,
		.rndadv = rndadv,
		.g = g,
		.off = off,
		.phi = phi,
		.complex_ptr = complex_ptr,
		.float_ptr = float_ptr,
		.length = length,
		.freqptr = freqptr,
		.phaseptr = phaseptr
	};

	rb_thread_call_without_gvl2(synthesize_loop, &p, RUBY_UBF_PROCESS, NULL);

	rb_ary_store(state, 0, rb_float_new(p.phi));

	if (!was_inplace) {
		UNSET_INPLACE(buffer);
	}

	RB_GC_GUARD(frequency);
	RB_GC_GUARD(buffer);
	RB_GC_GUARD(phase_mod);

	return buffer;
}

static VALUE ruby_biquad(VALUE self, VALUE b0, VALUE b1, VALUE b2, VALUE a1, VALUE a2, VALUE x0, VALUE x1, VALUE x2, VALUE y1, VALUE y2)
{
	double result = biquad_filter(
			NUM2DBL(b0), NUM2DBL(b1), NUM2DBL(b2),
			NUM2DBL(a1), NUM2DBL(a2),
			NUM2DBL(x0), NUM2DBL(x1), NUM2DBL(x2),
			NUM2DBL(y1), NUM2DBL(y2)
			);

	return rb_float_new(result);
}

static VALUE ruby_biquad_complex(VALUE self, VALUE b0, VALUE b1, VALUE b2, VALUE a1, VALUE a2, VALUE x0, VALUE x1, VALUE x2, VALUE y1, VALUE y2)
{
	double complex result = biquad_complex(
			num_to_complex(b0), num_to_complex(b1), num_to_complex(b2),
			num_to_complex(a1), num_to_complex(a2),
			num_to_complex(x0), num_to_complex(x1), num_to_complex(x2),
			num_to_complex(y1), num_to_complex(y2)
			);

	return complex_to_num(result);
}

#define BIQUAD_LOOP(buf_type, coeff_type, conv_from_rb, conv_to_rb, filter_func) do { \
	buf_type *data = (buf_type *)(nary_get_pointer_for_read_write(buf) + nary_get_offset(buf)); \
\
	coeff_type x0 = 0; \
	coeff_type x1 = conv_from_rb(rb_ary_entry(state, 1)); \
	coeff_type x2 = conv_from_rb(rb_ary_entry(state, 2)); \
	coeff_type y0 = 0; \
	coeff_type y1 = conv_from_rb(rb_ary_entry(state, 3)); \
	coeff_type y2 = conv_from_rb(rb_ary_entry(state, 4)); \
\
	coeff_type b0 = conv_from_rb(rb0); \
	coeff_type b1 = conv_from_rb(rb1); \
	coeff_type b2 = conv_from_rb(rb2); \
	coeff_type a1 = conv_from_rb(ra0); \
	coeff_type a2 = conv_from_rb(ra1); \
\
	for (size_t i = 0; i < length; i++) { \
		x0 = data[i]; \
		y0 = filter_func(b0, b1, b2, a1, a2, x0, x1, x2, y1, y2); \
		data[i] = y0; \
		y2 = y1; \
		y1 = y0; \
		x2 = x1; \
		x1 = x0; \
	} \
\
	rb_ary_store(state, 1, conv_to_rb(x1)); \
	rb_ary_store(state, 2, conv_to_rb(x2)); \
	rb_ary_store(state, 3, conv_to_rb(y1)); \
	rb_ary_store(state, 4, conv_to_rb(y2)); \
} while(0);

/*
 * Converted from lib/mb/sound/filter/biquad.rb
 *
 * buf must be a 1D Numo::DFloat or Numo::DComplex or compatible
 * state contains [buf, x1, x2, y1, y2]
 *
 * state will be mutated, and buf (state[0]) might be a different object!
 *
 * returns state
 */
static VALUE ruby_biquad_narray(VALUE self, VALUE rb0, VALUE rb1, VALUE rb2, VALUE ra0, VALUE ra1, VALUE state)
{
	VALUE buf, buf_type;

	Check_Type(state, T_ARRAY);

	buf = rb_ary_entry(state, 0);

	// References used for narray and Ruby APIs:
	// https://github.com/yoshoku/numo-pocketfft/blob/1ab489b165d4cde06b6d3a443ed9bfbc8e5c69d0/ext/numo/pocketfft/pocketfftext.c
	// https://github.com/ruby-numo/numo-narray/blob/6f5c91250c0cb948f6b811385d384c3f15af4dcd/ext/numo/narray/numo/intern.h
	// https://silverhammermba.github.io/emberb/c/
	// https://github.com/ruby/ruby/blob/master/doc/extension.rdoc

	// First try NArray's automatic conversion, to get e.g. from an array
	// of complex to DComplex
	buf_type = CLASS_OF(buf);
	if (buf_type != numo_cDComplex && buf_type != numo_cSComplex && buf_type != numo_cSFloat && buf_type != numo_cDFloat) {
		buf = rb_funcall(numo_cNArray, rb_intern("cast"), 1, buf);
		buf_type = CLASS_OF(buf);
	}

	// If that's still not a float or complex type, force conversion to float
	buf_type = CLASS_OF(buf);
	if (buf_type != numo_cDComplex && buf_type != numo_cSComplex && buf_type != numo_cSFloat && buf_type != numo_cDFloat) {
		buf = rb_funcall(numo_cDFloat, rb_intern("cast"), 1, buf);
		buf_type = CLASS_OF(buf);
	}

	int dim = RNARRAY_NDIM(buf);
	if (dim != 1) {
		rb_raise(rb_eArgError, "Only 1D NArrays may be processed (got %d dimensions)", dim);
	}

	_Bool was_inplace = !!TEST_INPLACE(buf);

	if (!RTEST(nary_check_contiguous(buf)) || !was_inplace) {
		buf = nary_dup(buf);
		SET_INPLACE(buf);
		was_inplace = 0;
	}

	size_t length = RNARRAY_SHAPE(buf)[0];

	if (buf_type == numo_cSFloat) {
		BIQUAD_LOOP(float, double, NUM2DBL, DBL2NUM, biquad_filter);
	} else if (buf_type == numo_cDFloat) {
		BIQUAD_LOOP(double, double, NUM2DBL, DBL2NUM, biquad_filter);
	} else if (buf_type == numo_cSComplex) {
		BIQUAD_LOOP(float complex, double complex, num_to_complex, complex_to_num, biquad_complex);
	} else if (buf_type == numo_cDComplex) {
		BIQUAD_LOOP(double complex, double complex, num_to_complex, complex_to_num, biquad_complex);
	} else {
		rb_raise(rb_eException, "BUG: Buffer was not SFloat, DFloat, SComplex, or DComplex");
	}

	if (!was_inplace) {
		UNSET_INPLACE(buf);
	}

	rb_ary_store(state, 0, buf);

	RB_GC_GUARD(buf);
	RB_GC_GUARD(state);

	return state;
}

/*
 * Generates cookbook filter biquad parameters, from lib/mb/sound/filter/cookbook.rb.
 *
 * Returns [omega, b0, b1, b2, a1, a2].
 */
static VALUE ruby_cookbook(VALUE self, VALUE type_id, VALUE f_samp, VALUE f_center, VALUE db_gain, VALUE quality, VALUE bandwidth_oct, VALUE shelf_slope)
{
	enum filter_types ftype = NUM2INT(type_id);

	if (!(RTEST(quality) || RTEST(bandwidth_oct) || RTEST(shelf_slope))) {
		rb_raise(rb_eArgError, "Missing quality/bandwidth_oct/shelf_slope");
	}

	if (!RTEST(db_gain) && (ftype == FILT_LOWSHELF || ftype == FILT_HIGHSHELF || ftype == FILT_PEAK)) {
		rb_raise(rb_eArgError, "Missing db_gain");
	}

	double g = RTEST(db_gain) ? NUM2DBL(db_gain) : NAN;
	double q = RTEST(quality) ? NUM2DBL(quality) : NAN;
	double bw = RTEST(bandwidth_oct) ? NUM2DBL(bandwidth_oct) : NAN;
	double ss = RTEST(shelf_slope) ? NUM2DBL(shelf_slope) : NAN;

	struct biquad_coeffs coeffs = cookbook(ftype, NUM2DBL(f_samp), NUM2DBL(f_center), g, q, bw, ss);

	VALUE out = rb_ary_new_capa(6);
	rb_ary_store(out, 0, rb_float_new(coeffs.omega));
	rb_ary_store(out, 1, rb_float_new(coeffs.b0));
	rb_ary_store(out, 2, rb_float_new(coeffs.b1));
	rb_ary_store(out, 3, rb_float_new(coeffs.b2));
	rb_ary_store(out, 4, rb_float_new(coeffs.a1));
	rb_ary_store(out, 5, rb_float_new(coeffs.a2));

	return out;
}

/*
 * Converted from lib/mb/sound/filter/cookbook.rb
 *
 * samples, cutoffs, and qualities should be 1D Numo::SFloat
 * state contains [x1, x2, y1, y2] and will be mutated
 * coeffs contains [omega, b0, b1, b2, a1, a2] and will be mutated
 *
 * returns samples
 */
static VALUE ruby_dynamic_biquad(VALUE self, VALUE samples, VALUE cutoffs, VALUE qualities, VALUE type_id, VALUE sample_rate, VALUE db_gain, VALUE coeffs, VALUE state)
{
	Check_Type(coeffs, T_ARRAY);
	Check_Type(state, T_ARRAY);

	_Bool was_inplace = 0;
	ensure_inplace_sfloat(&samples, &was_inplace);
	ensure_sfloat(&cutoffs);
	ensure_sfloat(&qualities);

	size_t length = RNARRAY_SHAPE(samples)[0];
	if (RNARRAY_SHAPE(cutoffs)[0] != length) {
		rb_raise(rb_eArgError, "Length of cutoff frequency array did not match length of sample array");
	}
	if (RNARRAY_SHAPE(qualities)[0] != length) {
		rb_raise(rb_eArgError, "Length of quality factor array did not match length of sample array");
	}

	enum filter_types ftype = NUM2INT(type_id);
	double g = RTEST(db_gain) ? NUM2DBL(db_gain) : NAN;
	double rate = NUM2DBL(sample_rate);

	// nary_get_offset / na_get_offset returns a byte offset, so add it before the cast
	float *samp = (float *)(nary_get_pointer_for_write(samples) + nary_get_offset(samples));
	float *cut = (float *)(nary_get_pointer_for_read(cutoffs) + nary_get_offset(cutoffs));
	float *q = (float *)(nary_get_pointer_for_read(qualities) + nary_get_offset(qualities));
	struct biquad_coeffs bq = {
		.b0 = NUM2DBL(rb_ary_entry(coeffs, 0)),
		.b1 = NUM2DBL(rb_ary_entry(coeffs, 1)),
		.b2 = NUM2DBL(rb_ary_entry(coeffs, 2)),
		.a1 = NUM2DBL(rb_ary_entry(coeffs, 3)),
		.a2 = NUM2DBL(rb_ary_entry(coeffs, 4)),
	};
	double x0;
	double x1 = NUM2DBL(rb_ary_entry(state, 0));
	double x2 = NUM2DBL(rb_ary_entry(state, 1));
	double y0;
	double y1 = NUM2DBL(rb_ary_entry(state, 2));
	double y2 = NUM2DBL(rb_ary_entry(state, 3));
	for (size_t i = 0; i < length; i++) {
		bq = cookbook(ftype, rate, cut[i], g, q[i], NAN, NAN);
		x0 = samp[i];
		y0 = biquad_filter(bq.b0, bq.b1, bq.b2, bq.a1, bq.a2, x0, x1, x2, y1, y2);
		samp[i] = y0;
		y2 = y1;
		y1 = y0;
		x2 = x1;
		x1 = x0;
	}

	if (!was_inplace) {
		UNSET_INPLACE(samples);
	}

	rb_ary_store(coeffs, 0, rb_float_new(bq.omega));
	rb_ary_store(coeffs, 1, rb_float_new(bq.b0));
	rb_ary_store(coeffs, 2, rb_float_new(bq.b1));
	rb_ary_store(coeffs, 3, rb_float_new(bq.b2));
	rb_ary_store(coeffs, 4, rb_float_new(bq.a1));
	rb_ary_store(coeffs, 5, rb_float_new(bq.a2));

	rb_ary_store(state, 0, rb_float_new(x1));
	rb_ary_store(state, 1, rb_float_new(x2));
	rb_ary_store(state, 2, rb_float_new(y1));
	rb_ary_store(state, 3, rb_float_new(y2));

	RB_GC_GUARD(samples);
	RB_GC_GUARD(cutoffs);
	RB_GC_GUARD(qualities);

	return samples;
}

VALUE ruby_adsr(VALUE self, VALUE time, VALUE attack, VALUE decay, VALUE sustain, VALUE release, VALUE peak, VALUE on)
{
	return rb_float_new(adsr(
				NUM2DBL(time),
				NUM2DBL(attack),
				NUM2DBL(decay),
				NUM2DBL(sustain),
				NUM2DBL(release),
				NUM2DBL(peak),
				RTEST(on)
				));
}

VALUE ruby_adsr_narray(VALUE self, VALUE narray, VALUE frame, VALUE rate, VALUE attack, VALUE decay, VALUE sustain, VALUE release, VALUE peak, VALUE on)
{
	if (CLASS_OF(narray) != numo_cDFloat && CLASS_OF(narray) != numo_cSFloat) {
		narray = rb_funcall(numo_cDFloat, rb_intern("cast"), 1, narray);
	}

	int dim = RNARRAY_NDIM(narray);
	if (dim != 1) {
		rb_raise(rb_eArgError, "Only 1D NArrays may be processed (got %d dimensions)", dim);
	}

	_Bool was_inplace = !!TEST_INPLACE(narray);

	if (!RTEST(nary_check_contiguous(narray)) || !was_inplace) {
		narray = nary_dup(narray);
		SET_INPLACE(narray);
		was_inplace = 0;
	}

	size_t length = RNARRAY_SHAPE(narray)[0];

	ssize_t current_frame = NUM2SSIZET(frame);
	double sample_rate = NUM2DBL(rate);
	double a = NUM2DBL(attack);
	double d = NUM2DBL(decay);
	double s = NUM2DBL(sustain);
	double r = NUM2DBL(release);
	double p = NUM2DBL(peak);
	_Bool o = RTEST(on);

	if (CLASS_OF(narray) == numo_cSFloat) {
		float *data = (float *)(nary_get_pointer_for_write(narray) + nary_get_offset(narray));

		for(size_t i = 0; i < length; i++) {
			double t = current_frame / sample_rate;
			data[i] = adsr(t, a, d, s, r, p, o);
			current_frame += 1;
		}
	} else if (CLASS_OF(narray) == numo_cDFloat) {
		double *data = (double *)(nary_get_pointer_for_write(narray) + nary_get_offset(narray));

		for(size_t i = 0; i < length; i++) {
			double t = current_frame / sample_rate;
			data[i] = adsr(t, a, d, s, r, p, o);
			current_frame += 1;
		}
	}

	RB_GC_GUARD(narray);

	return narray;
}

void Init_fast_sound(void)
{
	VALUE mb = rb_define_module("MB");
	VALUE fast_sound = rb_define_module_under(mb, "FastSound");

	sym_osc_sine = rb_intern("sine");
	sym_osc_complex_sine = rb_intern("complex_sine");
	sym_osc_triangle = rb_intern("triangle");
	sym_osc_complex_triangle = rb_intern("complex_triangle");
	sym_osc_square = rb_intern("square");
	sym_osc_complex_square = rb_intern("complex_square");
	sym_osc_ramp = rb_intern("ramp");
	sym_osc_complex_ramp = rb_intern("complex_ramp");
	sym_osc_gauss = rb_intern("gauss");
	sym_osc_parabola = rb_intern("parabola");

	// Oscillator functions
	rb_define_module_function(fast_sound, "osc", ruby_osc, 2);
	rb_define_module_function(fast_sound, "synthesize", ruby_synthesize, 9);

	// Filtering functions
	rb_define_module_function(fast_sound, "biquad", ruby_biquad, 10);
	rb_define_module_function(fast_sound, "biquad_complex", ruby_biquad_complex, 10);
	rb_define_module_function(fast_sound, "biquad_narray", ruby_biquad_narray, 6);
	rb_define_module_function(fast_sound, "dynamic_biquad", ruby_dynamic_biquad, 8);
	rb_define_module_function(fast_sound, "cookbook", ruby_cookbook, 7);

	// Envelope functions
	rb_define_module_function(fast_sound, "adsr", ruby_adsr, 7);
	rb_define_module_function(fast_sound, "adsr_narray", ruby_adsr_narray, 9);

	// Faster implementations of functions from mb-math
	rb_define_module_function(fast_sound, "cot_int", ruby_cot_int, 1);
	rb_define_module_function(fast_sound, "csc_int", ruby_csc_int, 1);
	rb_define_module_function(fast_sound, "csc_int_int", ruby_csc_int_int, 1);

	rb_define_module_function(fast_sound, "smoothstep", ruby_smoothstep, 1);
	rb_define_module_function(fast_sound, "smootherstep", ruby_smootherstep, 1);

	// Fills a given NArray with a smoothstep curve from 0 to 1
	rb_define_module_function(fast_sound, "smoothstep_buf", ruby_smoothstep_buf, 1);
	rb_define_module_function(fast_sound, "smootherstep_buf", ruby_smootherstep_buf, 1);

	// Mathematical functions that for some reason are missing from Numo::NArray
	rb_define_module_function(fast_sound, "narray_log", ruby_narray_log, 1);
	rb_define_module_function(fast_sound, "narray_log2", ruby_narray_log2, 1);
	rb_define_module_function(fast_sound, "narray_log10", ruby_narray_log10, 1);

	// Functions used when comparing C and Ruby's behavior for integer
	// division (C rounds to zero, Ruby rounds downward) and modulus (-1 %
	// 3 in Ruby is 2, in C it's -1)
	rb_define_module_function(fast_sound, "fmod", ruby_fmod, 2);
	rb_define_module_function(fast_sound, "remainder", ruby_remainder, 2);
	rb_define_module_function(fast_sound, "wrap", ruby_wrap, 2);
	rb_define_module_function(fast_sound, "wrapsize", ruby_wrapsize, 2);
	rb_define_module_function(fast_sound, "idiv", ruby_idiv, 2);
	rb_define_module_function(fast_sound, "fdiv", ruby_fdiv, 2);
	rb_define_module_function(fast_sound, "imod", ruby_imod, 2);
	rb_define_module_function(fast_sound, "f64to32", ruby_f64to32, 1);

	// Functions to test conversion to and from Ruby complex datatypes
	rb_define_module_function(fast_sound, "complex", ruby_complex, 1);
	rb_define_module_function(fast_sound, "narray_to_array", ruby_narray_to_array, 1);
}
